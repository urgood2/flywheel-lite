#!/usr/bin/env bash
# Force line-buffered output
export STDBUF_O=L
if [[ -z "${STDBUF_APPLIED:-}" ]] && command -v stdbuf &>/dev/null; then export STDBUF_APPLIED=1; exec stdbuf -oL bash "$0" "$@"; fi
# flywheel-plan-pro: Guided planning with GPT Pro web integration
# Interactive mode - choose to continue after each round
# Runs in tmux session for persistence across SSH disconnects
set -euo pipefail

export PATH="$HOME/.local/bin:$HOME/.cargo/bin:$PATH"

# Helpers
die() { echo "ERROR: $*" >&2; exit 1; }
note() { echo "==> $*" >&2; }

sanitize_session_name() {
  echo "$1" | tr "@.:" "---" | sed "s/[^a-zA-Z0-9_-]/-/g"
}

smart_attach() {
  local target="$1"
  if [[ -n "${TMUX:-}" ]]; then
    tmux switch-client -t "$target"
  else
    tmux attach -t "$target"
  fi
}

# Parse arguments
PLAN_INPUT=""
MAX_ROUNDS="${1:-3}"
INNER_LOOP=false
START_ROUND=1

while [[ $# -gt 0 ]]; do
    case "$1" in
        --plan) PLAN_INPUT="$2"; shift 2;;
        --rounds) MAX_ROUNDS="$2"; shift 2;;
        --_inner) INNER_LOOP=true; shift;;
        --_start-round) START_ROUND="$2"; shift 2;;
        [0-9]*) MAX_ROUNDS="$1"; shift;;
        *) shift;;
    esac
done

PROJECT_DIR="$(pwd)"
PROJECT_NAME="$(basename "$PROJECT_DIR")"
PLANNING_DIR="$PROJECT_DIR/planning"
STATE_FILE="$PROJECT_DIR/.flywheel/plan-pro-state.json"

# If not inner loop, handle tmux session management
if [[ "$INNER_LOOP" != "true" ]]; then
    session="plan-pro-$(sanitize_session_name "$PROJECT_NAME")"

    # Check for existing session
    if tmux has-session -t "$session" 2>/dev/null; then
        note "Plan-pro session already running: $session"
        note "Attaching... (Ctrl+B D to detach)"
        sleep 1
        smart_attach "$session"
        exit 0
    fi

    # Check for saved state to resume
    mkdir -p "$(dirname "$STATE_FILE")"
    if [[ -f "$STATE_FILE" ]]; then
        status=$(grep -oP '"status":\s*"\K[^"]*' "$STATE_FILE" 2>/dev/null || echo "")
        if [[ "$status" == "in_progress" ]]; then
            saved_round=$(grep -oP '"round":\s*\K[0-9]+' "$STATE_FILE" 2>/dev/null || echo "0")
            saved_plan=$(grep -oP '"current_plan":\s*"\K[^"]*' "$STATE_FILE" 2>/dev/null || echo "")
            if [[ "$saved_round" -gt 0 ]]; then
                note "Found interrupted plan-pro at round $saved_round"
                START_ROUND=$((saved_round))
                [[ -n "$saved_plan" && -f "$saved_plan" ]] && PLAN_INPUT="$saved_plan"
                note "Resuming from round $START_ROUND"
            fi
        elif [[ "$status" == "complete" ]]; then
            note "Previous plan-pro completed. Starting fresh."
            rm -f "$STATE_FILE"
        fi
    fi

    note "Starting plan-pro session: $session"
    note "Detach: Ctrl+B D | Reattach: flywheel plan-pro (or tmux attach -t $session)"
    sleep 2

    # Build args for inner loop
    inner_args=(--_inner --_start-round "$START_ROUND")
    [[ -n "$PLAN_INPUT" ]] && inner_args+=(--plan "$PLAN_INPUT")
    inner_args+=(--rounds "$MAX_ROUNDS")

    # Start tmux session with inner loop
    tmux new-session -d -s "$session" "cd '$PROJECT_DIR' && flywheel-plan-pro ${inner_args[*]}"
    smart_attach "$session"
    exit 0
fi

# ============================================================================
# INNER LOOP - runs inside tmux
# ============================================================================

save_state() {
    local status="$1" round="$2" plan="$3"
    mkdir -p "$(dirname "$STATE_FILE")"
    cat > "$STATE_FILE" <<EOF
{
  "status": "$status",
  "round": $round,
  "current_plan": "$plan",
  "updated": "$(date -Iseconds)"
}
EOF
}

# Colors
RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[1;33m"
BLUE="\033[0;34m"
CYAN="\033[0;36m"
BOLD="\033[1m"
NC="\033[0m"

# Create planning directory
mkdir -p "$PLANNING_DIR"

clear 2>/dev/null || true
echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${BLUE}â•‘  ${BOLD}FLYWHEEL PLAN-PRO${NC}${BLUE} - Guided Planning with GPT Pro Integration   â•‘${NC}"
echo -e "${BLUE}â•‘  Project: $PROJECT_NAME${NC}"
echo -e "${BLUE}â•‘  Mode: Interactive (continue/stop after each round)${NC}"
echo -e "${BLUE}â•‘  Session: Persistent (Ctrl+B D to detach, rerun to reattach)${NC}"
echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo

# ============================================================================
# STEP 1: Initial Plan (with auto-detection)
# ============================================================================
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${CYAN}  STEP 1: Initial Plan${NC}"
echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo

# Determine which plan to use
if [[ -n "$PLAN_INPUT" && -f "$PLAN_INPUT" ]]; then
    # User specified a plan file (or resuming from state)
    CURRENT_PLAN="$PLAN_INPUT"
    echo -e "${GREEN}âœ“ Using plan: $CURRENT_PLAN${NC}"
elif [[ -f "$PLANNING_DIR/PLAN.md" ]]; then
    # Auto-detect refined plan (output of flywheel refine)
    CURRENT_PLAN="$PLANNING_DIR/PLAN.md"
    echo -e "${GREEN}âœ“ Found refined plan: $CURRENT_PLAN${NC}"
    echo -e "  ${YELLOW}(This is the output from flywheel refine)${NC}"
elif [[ -f "$PLANNING_DIR/PLAN_v0.md" ]]; then
    CURRENT_PLAN="$PLANNING_DIR/PLAN_v0.md"
    echo -e "${GREEN}âœ“ Found initial plan: $CURRENT_PLAN${NC}"
else
    echo -e "${YELLOW}No plan found.${NC}"
    echo
    echo "Options:"
    echo "  1) Run 'flywheel plan' first for interactive interview"
    echo "  2) Run 'flywheel refine' to refine an existing plan"
    echo "  3) Run 'flywheel compete' for multi-model plan generation"
    echo "  4) Create $PLANNING_DIR/PLAN_v0.md manually"
    echo "  5) Specify plan with: flywheel plan-pro --plan <file>"
    echo
    read -p "Press Enter after creating initial plan, or Ctrl+C to exit..."

    # Re-check after user action
    if [[ -f "$PLANNING_DIR/PLAN.md" ]]; then
        CURRENT_PLAN="$PLANNING_DIR/PLAN.md"
    elif [[ -f "$PLANNING_DIR/PLAN_v0.md" ]]; then
        CURRENT_PLAN="$PLANNING_DIR/PLAN_v0.md"
    else
        echo -e "${RED}Error: Still no plan found. Exiting.${NC}"
        exit 1
    fi
fi

echo -e "  Lines: $(wc -l < "$CURRENT_PLAN") | Size: $(du -h "$CURRENT_PLAN" | cut -f1)"

# Check if resuming mid-round
round=$((START_ROUND - 1))
if [[ $START_ROUND -gt 1 ]]; then
    echo -e "${YELLOW}Resuming from round $START_ROUND${NC}"
fi

# Interactive Refinement Loop
# ============================================================================
while true; do
    ((++round))

    # Save state at start of each round
    save_state "in_progress" "$round" "$CURRENT_PLAN"

    echo
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${CYAN}  ROUND $round: GPT Pro Review${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo

    # Show plan location
    echo -e "${BOLD}ğŸ“„ Current Plan:${NC} $CURRENT_PLAN"
    echo -e "   Lines: $(wc -l < "$CURRENT_PLAN") | Size: $(du -h "$CURRENT_PLAN" | cut -f1)"
    echo

    # The GPT Pro review prompt
    GPT_PROMPT='Carefully review this entire plan for me and come up with your best revisions
in terms of better architecture, new features, changed features, etc. to make
it better, more robust/reliable, more performant, more compelling/useful, etc.
For each proposed change, give me your detailed analysis and rationale/justification
for why it would make the project better along with the git-diff style change
versus the original plan shown below.

At the end of your response, provide a COMPLETE REVISED PLAN as a downloadable
markdown file that incorporates all your approved changes. This should be a
standalone document I can save directly.

---

'

    # Copy prompt + plan to clipboard (with OSC 52 for SSH support)
    clipboard_copy_content() {
        local content="$1"
        # Method 1: OSC 52 escape sequence (works over SSH in iTerm2, kitty, Ghostty, etc.)
        if [[ -n "${SSH_TTY:-}" || -n "${SSH_CLIENT:-}" ]]; then
            local encoded
            encoded=$(echo -n "$content" | base64 | tr -d '\n')
            printf '\e]52;c;%s\a' "$encoded" 2>/dev/null && return 0
        fi
        # Method 2: Local clipboard tools
        if command -v pbcopy &>/dev/null; then
            echo -n "$content" | pbcopy 2>/dev/null && return 0
        elif command -v xclip &>/dev/null && [[ -n "${DISPLAY:-}" ]]; then
            echo -n "$content" | xclip -selection clipboard 2>/dev/null && return 0
        elif command -v xsel &>/dev/null && [[ -n "${DISPLAY:-}" ]]; then
            echo -n "$content" | xsel --clipboard 2>/dev/null && return 0
        fi
        return 1
    }

    # Combine prompt + plan for clipboard
    CLIPBOARD_CONTENT="${GPT_PROMPT}$(cat "$CURRENT_PLAN")"

    if clipboard_copy_content "$CLIPBOARD_CONTENT"; then
        echo -e "${GREEN}âœ“ Prompt + Plan copied to clipboard!${NC}"
    else
        echo -e "${YELLOW}âš  Could not auto-copy to clipboard.${NC}"
    fi
    # Always show fallback command
    echo -e "  ${CYAN}Fallback (run locally):${NC} ssh vps \"cat $CURRENT_PLAN\" | pbcopy"
    echo

    # Show the prompt visually (in case clipboard fails or for reference)
    echo -e "${BOLD}ğŸ“‹ GPT 5.2 PRO PROMPT (already in clipboard):${NC}"
    echo -e "${YELLOW}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -n "$GPT_PROMPT" | head -c -4  # Remove trailing newlines and ---
    echo -e "${YELLOW}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo
    echo -e "${BOLD}Then paste your plan content after the prompt.${NC}"
    echo

    # Wait for user to complete GPT Pro review
    echo -e "${CYAN}ğŸŒ Open: https://chat.openai.com (GPT Pro with Extended Reasoning)${NC}"
    echo
    read -p "Press Enter when GPT Pro has finished reviewing..."
    echo

    # Get GPT output
    echo -e "${BOLD}ğŸ“¥ Paste GPT Pro's response below (end with Ctrl+D on empty line):${NC}"
    GPT_OUTPUT_FILE="$PLANNING_DIR/gpt_round${round}.md"
    cat > "$GPT_OUTPUT_FILE"
    echo
    echo -e "${GREEN}âœ“ Saved GPT output to: $GPT_OUTPUT_FILE${NC}"
    echo -e "   Lines: $(wc -l < "$GPT_OUTPUT_FILE")"
    echo

    # Integration phase
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${CYAN}  ROUND $round: Claude Code Integration${NC}"
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo

    NEW_PLAN="$PLANNING_DIR/PLAN_v${round}.md"

    echo -e "${BOLD}Running Claude Code to integrate revisions...${NC}"
    echo -e "Creating: $NEW_PLAN"
    echo

    # Create integration prompt
    INTEGRATE_PROMPT="Read the current plan at $CURRENT_PLAN and integrate the following GPT Pro revisions.
Save the integrated plan as $NEW_PLAN.

Use ultrathink. Be meticulous. At the end, tell me which changes you wholeheartedly agree with,
which you somewhat agree with, and which you disagree with.

GPT Pro's revisions:

$(cat "$GPT_OUTPUT_FILE")"

    # Run Claude Code
    if command -v claude &> /dev/null; then
        echo "$INTEGRATE_PROMPT" | claude --dangerously-skip-permissions 2>&1 | tee "$PLANNING_DIR/integration_round${round}.log"
    else
        echo -e "${RED}Error: claude command not found${NC}"
        echo "Please integrate manually"
    fi

    # Check if new plan was created
    if [[ -f "$NEW_PLAN" ]]; then
        echo
        echo -e "${GREEN}âœ“ Created: $NEW_PLAN${NC}"
        echo -e "   Lines: $(wc -l < "$NEW_PLAN")"
        CURRENT_PLAN="$NEW_PLAN"

        # Update state with new plan
        save_state "in_progress" "$round" "$CURRENT_PLAN"

        # Show diff
        if [[ $round -gt 1 ]]; then
            PREV_PLAN="$PLANNING_DIR/PLAN_v$((round-1)).md"
            if [[ -f "$PREV_PLAN" ]]; then
                echo
                echo -e "${BOLD}Changes from v$((round-1)) to v$round:${NC}"
                diff --stat "$PREV_PLAN" "$NEW_PLAN" 2>/dev/null || true
            fi
        fi
    else
        echo -e "${YELLOW}âš  Plan file not auto-created. Check output above.${NC}"
        read -p "Press Enter after manually creating $NEW_PLAN (or Ctrl+C to stop)..."
        [[ -f "$NEW_PLAN" ]] && CURRENT_PLAN="$NEW_PLAN"
    fi

    # Ask to continue
    echo
    echo -e "${BOLD}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -e "Completed $round round(s) of refinement."
    echo -e "Current plan: $CURRENT_PLAN ($(wc -l < "$CURRENT_PLAN") lines)"
    echo
    read -p "Continue to another round? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        break
    fi
done

# ============================================================================
# FINAL: Summary and Next Steps
# ============================================================================
echo
echo -e "${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${GREEN}â•‘  ${BOLD}PLAN REFINEMENT COMPLETE${NC}${GREEN}                                        â•‘${NC}"
echo -e "${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo

# Mark complete
save_state "complete" "$round" "$CURRENT_PLAN"

echo -e "${BOLD}ğŸ“„ Plan Versions:${NC}"
ls -la "$PLANNING_DIR"/PLAN_v*.md 2>/dev/null | while read line; do
    echo "   $line"
done
echo
echo -e "${BOLD}ğŸ“„ Final Plan:${NC} $CURRENT_PLAN"
echo -e "   Lines: $(wc -l < "$CURRENT_PLAN")"
echo

# Copy final plan to PLAN.md
cp "$CURRENT_PLAN" "$PLANNING_DIR/PLAN.md"
echo -e "${GREEN}âœ“ Copied to: $PLANNING_DIR/PLAN.md${NC}"
echo

echo -e "${BOLD}Next Steps:${NC}"
echo "  1. flywheel beads              # Convert plan to beads"
echo "  2. flywheel polish --max 9     # Polish beads (6-9 iterations)"
echo "  3. flywheel startwork --cc 2   # Start agent swarm"
echo

# Ask to continue to beads
echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
read -p "Continue to beads? [Y/n] " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Nn]$ ]]; then
    echo -e "${GREEN}Starting flywheel beads...${NC}"
    echo
    exec flywheel beads --plan "$PLANNING_DIR/PLAN.md"
fi
