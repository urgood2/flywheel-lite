#!/usr/bin/env bash
set -euo pipefail

# Flywheel-Lite with persistent tmux sessions

die() { echo "ERROR: $*" >&2; exit 1; }
note() { echo "==> $*" >&2; }

load_config() {
  local repo_root="${1:-}"
  [[ -f "$HOME/.config/flywheel/config.env" ]] && source "$HOME/.config/flywheel/config.env"
  [[ -n "$repo_root" && -f "$repo_root/.flywheel/config.env" ]] && source "$repo_root/.flywheel/config.env"
  : "${FW_INTERVIEW_ROUNDS:=2}" "${FW_PLAN_ITERS:=3}" "${FW_CC:=3}" "${FW_COD:=2}" "${FW_GMI:=1}"
  : "${FW_CLAUDE_MODEL:=opus}" "${FW_CODEX_IMPL_MODEL:=gpt-5.2-codex}" "${FW_GPT_PLAN_MODEL:=gpt-5.2}"
  : "${FW_CODEX_REASONING:=high}" "${FW_GEMINI_MODEL:=gemini-2.5-pro}" "${FW_SAFE:=0}"
}

git_root() { git rev-parse --show-toplevel 2>/dev/null || return 1; }
require_cmd() { command -v "$1" >/dev/null 2>&1 || die "Missing: $1"; }

usage() {
  cat >&2 <<'USAGE'
flywheel â€” oh-my-opencode style workflow on Agent Flywheel

Usage:
  flywheel doctor
  flywheel checkout <branch> [base]
  flywheel init
  flywheel plan [--rounds N]
  flywheel refine [--iters N] [--plan FILE]    # Runs in tmux, attach/detach safe
  flywheel beads [--plan FILE] [--min-beads N]
  flywheel compete                              # Generate 3 competing plans + synthesize
  flywheel startwork [--cc N] [--cod N] [--gmi N]
  flywheel status                              # Show refine/beads progress
  flywheel attach [session]                    # Attach to refine/beads session
  flywheel jobs                                # List all sessions

Refine runs in a persistent tmux session. Detach with Ctrl+B D, reattach with:
  flywheel attach
USAGE
}

doctor() {
  note "Checking dependencies..."
  for cmd in git tmux ntm bd bv apr ubs claude codex gemini; do require_cmd "$cmd"; done
  note "Running: ntm deps -v"
  ntm deps -v
  note "OK: toolchain present."
}

checkout_branch() {
  local branch="${1:-}" base="${2:-}"
  [[ -n "$branch" ]] || die "checkout requires <branch>"
  local root; root="$(git_root)" || die "Not in a git repo."
  cd "$root"; git fetch --all --prune
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    note "Checking out: $branch"; git checkout "$branch"; return 0
  fi
  if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
    note "Tracking origin/$branch"; git checkout -b "$branch" --track "origin/$branch"; return 0
  fi
  [[ -z "$base" ]] && base="$(git rev-parse --abbrev-ref HEAD)"
  note "Creating: $branch (from $base)"
  git checkout "$base"; git pull --ff-only || true; git checkout -b "$branch"
}

init_repo() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"; cd "$root"
  mkdir -p .flywheel planning
  [[ -f .flywheel/config.env ]] || echo "# Repo-local overrides" > .flywheel/config.env
  note "Initializing Beads..."; bd init 2>/dev/null || true
  bd config set sync.branch beads-sync 2>/dev/null || true
  if [[ ! -f AGENTS.md ]]; then
    cat > AGENTS.md <<'EOF'
# AGENTS.md
Multi-agent repo via NTM. Use Agent Mail for coordination. Run UBS before commits.
EOF
    note "Wrote AGENTS.md"
  fi
  note "Repo initialized. Next: flywheel plan"
}

plan_session() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local rounds="${1:-$FW_INTERVIEW_ROUNDS}"
  local session; session="$(basename "$root")"
  cd "$root"
  note "Spawning planning session: $session"
  ntm spawn "$session" --cc=1
  sleep 3
  ntm send "$session" --no-cass-check --all "You are the INTERVIEWER. Run ${rounds} interview rounds, then write planning/INTERVIEW_TRANSCRIPT.md and planning/PLAN_v0.md." || true
  note "Attaching..."
  ntm attach "$session"
}

find_latest_iter() {
  local root="$1"
  local latest=$(ls -t "$root/planning/PLAN_codex_iter"*.md 2>/dev/null | head -1)
  if [[ -n "$latest" ]]; then
    echo "$latest" | grep -oE 'iter[0-9]+' | grep -oE '[0-9]+'
  else
    echo "0"
  fi
}

# The actual refine loop (runs inside tmux)
_refine_loop() {
  local root="$1" iters="$2" plan_in="$3" start_iter="$4"
  
  cd "$root"
  source "$HOME/.config/flywheel/config.env" 2>/dev/null || true
  : "${FW_GPT_PLAN_MODEL:=gpt-5.2}" "${FW_CODEX_REASONING:=high}"
  
  mkdir -p planning .flywheel
  
  local prev="$plan_in"
  for i in $(seq "$start_iter" "$iters"); do
    local next="planning/PLAN_codex_iter${i}.md"
    
    # Save state
    cat > "$root/.flywheel/refine-state.json" <<EOF
{"current_iter": $i, "total_iters": $iters, "plan_in": "$prev", "timestamp": "$(date -Iseconds)", "status": "in_progress"}
EOF
    
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  ITERATION $i / $iters"
    echo "  Input: $prev"
    echo "  Output: $next"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    
    if ! codex exec --model "$FW_GPT_PLAN_MODEL" \
      --config "model_reasoning_effort=\"${FW_CODEX_REASONING}\"" \
      --output-last-message "$next" \
      "Read ${prev}. Rewrite into a better engineering plan with specificity, testability, parallelizability. Markdown only."; then
      echo ""
      echo "ERROR: Iteration $i failed!"
      echo "State saved. Restart with: flywheel refine"
      read -p "Press Enter to exit..."
      return 1
    fi
    
    prev="$next"
    echo ""
    echo "âœ“ Iteration $i complete: $next ($(wc -c < "$next") bytes)"
  done
  
  cp "$prev" planning/PLAN.md
  
  # Mark complete
  cat > "$root/.flywheel/refine-state.json" <<EOF
{"current_iter": $iters, "total_iters": $iters, "plan_in": "$prev", "timestamp": "$(date -Iseconds)", "status": "complete"}
EOF
  
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "  REFINEMENT COMPLETE"
  echo "  Final plan: planning/PLAN.md ($(wc -c < planning/PLAN.md) bytes)"
  echo "  Total iterations: $iters"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "Next: flywheel beads"
  echo ""
  read -p "Press Enter to close this session..."
}

refine_plan() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local iters="$FW_PLAN_ITERS" plan_in="planning/PLAN_v0.md"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --iters) iters="$2"; shift 2;;
      --plan) plan_in="$2"; shift 2;;
      --_loop) shift; _refine_loop "$@"; return;;
      *) die "Unknown: $1";;
    esac
  done
  cd "$root"
  
  local session="refine-$(basename "$root")"
  local start_iter=1
  
  # Check for existing session
  if tmux has-session -t "$session" 2>/dev/null; then
    note "Refine session already running: $session"
    note "Attaching... (Ctrl+B D to detach)"
    sleep 1
    tmux attach -t "$session"
    return 0
  fi
  
  # Check for interrupted refine
  local state_file="$root/.flywheel/refine-state.json"
  if [[ -f "$state_file" ]]; then
    local status=$(grep -oP '(?<="status": ")[^"]*' "$state_file" 2>/dev/null || echo "")
    if [[ "$status" == "in_progress" ]]; then
      local latest_iter=$(find_latest_iter "$root")
      if [[ "$latest_iter" -gt 0 ]]; then
        note "Found interrupted refine at iteration $latest_iter"
        plan_in="planning/PLAN_codex_iter${latest_iter}.md"
        start_iter=$((latest_iter + 1))
        local saved_total=$(grep -oP '(?<="total_iters": )[0-9]+' "$state_file" 2>/dev/null || echo "$iters")
        [[ "$saved_total" -gt "$iters" ]] && iters="$saved_total"
        note "Resuming from iteration $start_iter (target: $iters)"
      fi
    elif [[ "$status" == "complete" ]]; then
      note "Previous refine completed. Starting fresh."
      note "Use --plan to specify a different starting point"
    fi
  fi
  
  [[ -f "$plan_in" ]] || die "Missing: $plan_in"
  
  note "Starting refine session: $session"
  note "Iterations: $start_iter to $iters"
  note "Input: $plan_in"
  echo ""
  note "Detach anytime with: Ctrl+B D"
  note "Reattach with: flywheel attach"
  echo ""
  sleep 2
  
  # Start tmux session with refine loop
  tmux new-session -d -s "$session" \
    "cd '$root' && flywheel refine --_loop '$root' $iters '$plan_in' $start_iter"
  
  # Attach to it
  tmux attach -t "$session"
}

make_beads() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local plan="planning/PLAN.md" min_beads="50"
  while [[ $# -gt 0 ]]; do
    case "$1" in 
      --plan) plan="$2"; shift 2;; 
      --min-beads) min_beads="$2"; shift 2;; 
      *) die "Unknown: $1";; 
    esac
  done
  cd "$root"
  [[ -f "$plan" ]] || die "Missing: $plan"
  bd init 2>/dev/null || true

  local session="beads-$(basename "$root")"
  
  # Check for existing session
  if tmux has-session -t "$session" 2>/dev/null; then
    note "Beads session already running: $session"
    note "Attaching... (Ctrl+B D to detach)"
    sleep 1
    tmux attach -t "$session"
    return 0
  fi

  local prompt="You are a task decomposition expert. Read ${plan} and create Beads tasks.

RULES:
1. Create an EPIC first for the main feature
2. Create ${min_beads}+ sub-tasks with clear acceptance criteria
3. Use priorities: P1 (critical path), P2 (important), P3 (polish)
4. Set dependencies between tasks using --parent

COMMANDS:
- br add -t epic -p P1 'Epic Title' 'Epic description'
- br add -t task -p P1 'Task Title' 'Detailed acceptance criteria'
- br update <id> --parent <epic-id>

After creating all tasks, run: bv --robot-triage
Then say BEADS_COMPLETE when done."

  note "Starting beads session: $session"
  note "Detach anytime with: Ctrl+B D"
  note "Reattach with: flywheel attach"
  sleep 2

  tmux new-session -d -s "$session" "cd '$root' && claude --dangerously-skip-permissions"
  sleep 3
  tmux send-keys -t "$session" "$prompt" Enter
  tmux attach -t "$session"
}

startwork() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local session; session="$(basename "$root")"
  local cc_n="$FW_CC" cod_n="$FW_COD" gmi_n="$FW_GMI"
  while [[ $# -gt 0 ]]; do
    case "$1" in --cc) cc_n="$2"; shift 2;; --cod) cod_n="$2"; shift 2;; --gmi) gmi_n="$2"; shift 2;; *) die "Unknown: $1";; esac
  done
  cd "$root"
  local args=()
  [[ "$cc_n" -gt 0 ]] && args+=(--cc="$cc_n")
  [[ "$cod_n" -gt 0 ]] && args+=(--cod="$cod_n")
  [[ "$gmi_n" -gt 0 ]] && args+=(--gmi="$gmi_n")
  note "Spawning: $session cc=$cc_n cod=$cod_n gmi=$gmi_n"
  ntm spawn "$session" "${args[@]}"
  sleep 3
  ntm send "$session" --no-cass-check --all "Swarm SOP: bv --robot-triage, claim bead, reserve files, implement, close bead, notify." || true
  note "Attach: ntm attach $session"
}

show_status() {
  local root; root="$(git_root)" || die "Not in a git repo."
  local name=$(basename "$root")
  cd "$root"
  
  echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  echo "â•‘  FLYWHEEL STATUS: $name"
  echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  
  # Check for running refine session
  if tmux has-session -t "refine-$name" 2>/dev/null; then
    echo "ðŸ”„ REFINE SESSION RUNNING: refine-$name"
    echo "   Attach: flywheel attach"
    echo ""
  fi
  
  # Refine state
  echo "=== REFINE STATUS ==="
  local state_file="$root/.flywheel/refine-state.json"
  if [[ -f "$state_file" ]]; then
    local status=$(grep -oP '(?<="status": ")[^"]*' "$state_file" 2>/dev/null || echo "unknown")
    local current=$(grep -oP '(?<="current_iter": )[0-9]+' "$state_file" 2>/dev/null || echo "?")
    local total=$(grep -oP '(?<="total_iters": )[0-9]+' "$state_file" 2>/dev/null || echo "?")
    echo "  Status: $status"
    echo "  Progress: $current / $total iterations"
  else
    echo "  No refine started"
  fi
  
  # Iterations
  echo ""
  echo "=== PLAN FILES ==="
  local iter_count=$(ls planning/PLAN_codex_iter*.md 2>/dev/null | wc -l)
  echo "  Iterations: $iter_count"
  local latest=$(find_latest_iter "$root")
  [[ "$latest" -gt 0 ]] && echo "  Latest: iter$latest ($(wc -c < "planning/PLAN_codex_iter${latest}.md") bytes)"
  [[ -f planning/PLAN.md ]] && echo "  PLAN.md: $(wc -c < planning/PLAN.md) bytes"
  
  # Sessions
  echo ""
  echo "=== SESSIONS ==="
  tmux ls 2>/dev/null | grep -E "(refine-|beads-)?$name" | sed 's/^/  /' || echo "  None"
}

attach_session() {
  local root; root="$(git_root 2>/dev/null)" || root="."
  local name=$(basename "$root")
  local target="${1:-}"
  
  # If no target, try to find a relevant session
  if [[ -z "$target" ]]; then
    # Priority: refine > beads > project
    if tmux has-session -t "refine-$name" 2>/dev/null; then
      target="refine-$name"
    elif tmux has-session -t "beads-$name" 2>/dev/null; then
      target="beads-$name"
    elif tmux has-session -t "$name" 2>/dev/null; then
      target="$name"
    else
  flywheel compete                              # Generate 3 competing plans + synthesize
      die "No active session found. Run flywheel refine or flywheel startwork first."
    fi
  fi
  
  note "Attaching to: $target (Ctrl+B D to detach)"
  tmux attach -t "$target"
}

list_jobs() {
  echo "=== FLYWHEEL SESSIONS ==="
  tmux list-sessions 2>/dev/null | grep -E "^(refine-|beads-)" | sed 's/^/  /' || echo "  None"
  echo ""
  echo "=== ALL SESSIONS ==="
  tmux list-sessions 2>/dev/null | sed 's/^/  /' || echo "  None"
  echo ""
  echo "Attach: flywheel attach <session-name>"
}

main() {
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    doctor) doctor;;
    checkout) checkout_branch "$@";;
    init) init_repo;;
    plan) local r=""; while [[ $# -gt 0 ]]; do case "$1" in --rounds) r="$2"; shift 2;; *) die "Unknown: $1";; esac; done; plan_session "${r:-}";;
    refine) refine_plan "$@";;
    beads) make_beads "$@";;
    compete) compete_plans;;
    startwork) startwork "$@";;
    status) show_status;;
    jobs) list_jobs;;
    attach) attach_session "${1:-}";;
    ""|-h|--help|help) usage;;
    *) usage; die "Unknown: $cmd";;
  esac
}

main "$@"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMPETITIVE PLANNING: Generate plans from multiple models, synthesize
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

compete_plans() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  cd "$root"
  mkdir -p planning/competing
  
  local context_file="planning/PLAN_v0.md"
  [[ -f "$context_file" ]] || context_file="planning/INTERVIEW_TRANSCRIPT.md"
  [[ -f "$context_file" ]] || die "No context file. Run flywheel plan first."
  
  local session="compete-$(basename "$root")"
  
  if tmux has-session -t "$session" 2>/dev/null; then
    note "Compete session running. Attaching..."
    tmux attach -t "$session"
    return 0
  fi
  
  note "Starting competitive planning session: $session"
  note "Context: $context_file"
  note ""
  note "This will generate plans from Claude, Codex, and Gemini in parallel,"
  note "then synthesize them with GPT-5.2 Pro."
  note ""
  sleep 2
  
  tmux new-session -d -s "$session" "cd '$root' && _compete_runner '$context_file'"
  tmux attach -t "$session"
}

_compete_runner() {
  local context_file="$1"
  local root=$(pwd)
  
  echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  echo "â•‘          COMPETITIVE PLAN GENERATION                          â•‘"
  echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  
  local prompt_base="Read the following context and create a comprehensive implementation plan.

REQUIREMENTS:
- Be specific about files, functions, data structures
- Include clear phases with dependencies
- Add acceptance criteria for each task
- Consider edge cases and error handling
- Make it parallelizable for multi-agent execution

CONTEXT:
$(cat "$context_file")

OUTPUT: A detailed engineering plan in Markdown format."

  # Generate plans in parallel using background processes
  echo "=== Phase 1: Generating competing plans ==="
  echo ""
  
  echo "[1/3] Starting Claude plan generation..."
  (claude --print "$prompt_base" > planning/competing/claude_plan.md 2>&1 && \
   echo "âœ“ Claude plan complete: $(wc -c < planning/competing/claude_plan.md) bytes") &
  local pid_claude=$!
  
  echo "[2/3] Starting Codex plan generation..."
  (codex exec --model gpt-5.2 --config "model_reasoning_effort=\"high\"" \
   --output-last-message planning/competing/codex_plan.md \
   "$prompt_base" 2>&1 && \
   echo "âœ“ Codex plan complete: $(wc -c < planning/competing/codex_plan.md) bytes") &
  local pid_codex=$!
  
  echo "[3/3] Starting Gemini plan generation..."
  (gemini --print "$prompt_base" > planning/competing/gemini_plan.md 2>&1 && \
   echo "âœ“ Gemini plan complete: $(wc -c < planning/competing/gemini_plan.md) bytes") &
  local pid_gemini=$!
  
  echo ""
  echo "Waiting for all plans to complete..."
  echo "(This may take several minutes)"
  echo ""
  
  wait $pid_claude $pid_codex $pid_gemini
  
  echo ""
  echo "=== Phase 2: Synthesizing with GPT-5.2 Pro ==="
  echo ""
  
  local synth_prompt="You are a senior software architect. You have received THREE competing implementation plans for the same project from different AI models.

Your task: Synthesize these into ONE master plan that:
1. Takes the BEST ideas from each plan
2. Resolves any contradictions by picking the superior approach
3. Ensures consistency and completeness
4. Adds anything important that all plans missed
5. Optimizes for parallel execution by multiple agents

## CLAUDE PLAN:
$(cat planning/competing/claude_plan.md 2>/dev/null || echo "Failed to generate")

## CODEX PLAN:
$(cat planning/competing/codex_plan.md 2>/dev/null || echo "Failed to generate")

## GEMINI PLAN:
$(cat planning/competing/gemini_plan.md 2>/dev/null || echo "Failed to generate")

## YOUR TASK:
Create a synthesized MASTER PLAN that combines the best elements. Output only the final plan in Markdown format."

  echo "Running GPT-5.2 Pro synthesis (xhigh reasoning)..."
  echo ""
  
  if codex exec --model gpt-5.2 \
    --config "model_reasoning_effort=\"xhigh\"" \
    --output-last-message planning/PLAN_synthesized.md \
    "$synth_prompt"; then
    
    cp planning/PLAN_synthesized.md planning/PLAN_v0.md
    
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘          SYNTHESIS COMPLETE                                   â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "Generated plans:"
    ls -la planning/competing/*.md 2>/dev/null | awk '{print "  " $NF " (" $5 " bytes)"}'
    echo ""
    echo "Synthesized plan:"
    echo "  planning/PLAN_synthesized.md ($(wc -c < planning/PLAN_synthesized.md) bytes)"
    echo "  (Also copied to planning/PLAN_v0.md)"
    echo ""
    echo "Next steps:"
    echo "  flywheel refine --iters 5    # Further refine the synthesized plan"
    echo "  flywheel beads               # Or go straight to task creation"
  else
    echo ""
    echo "ERROR: Synthesis failed!"
  fi
  
  echo ""
  read -p "Press Enter to close..."
}
