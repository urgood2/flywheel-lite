#!/usr/bin/env bash
set -euo pipefail

# Flywheel-Lite with resumable refinement

die() { echo "ERROR: $*" >&2; exit 1; }
note() { echo "==> $*" >&2; }

load_config() {
  local repo_root="${1:-}"
  [[ -f "$HOME/.config/flywheel/config.env" ]] && source "$HOME/.config/flywheel/config.env"
  [[ -n "$repo_root" && -f "$repo_root/.flywheel/config.env" ]] && source "$repo_root/.flywheel/config.env"
  : "${FW_INTERVIEW_ROUNDS:=2}" "${FW_PLAN_ITERS:=3}" "${FW_CC:=3}" "${FW_COD:=2}" "${FW_GMI:=1}"
  : "${FW_CLAUDE_MODEL:=opus}" "${FW_CODEX_IMPL_MODEL:=gpt-5.2-codex}" "${FW_GPT_PLAN_MODEL:=gpt-5.2}"
  : "${FW_CODEX_REASONING:=high}" "${FW_GEMINI_MODEL:=gemini-2.5-pro}" "${FW_SAFE:=0}"
}

git_root() { git rev-parse --show-toplevel 2>/dev/null || return 1; }
require_cmd() { command -v "$1" >/dev/null 2>&1 || die "Missing: $1"; }

usage() {
  cat >&2 <<'USAGE'
flywheel — oh-my-opencode style workflow on Agent Flywheel

Usage:
  flywheel doctor
  flywheel checkout <branch> [base]
  flywheel init
  flywheel plan [--rounds N]
  flywheel refine [--iters N] [--plan FILE] [--bg] [--resume]
  flywheel beads [--plan FILE] [--min-beads N] [--bg]
  flywheel startwork [--cc N] [--cod N] [--gmi N]
  flywheel status                  # Show refine/beads progress
  flywheel jobs                    # List background jobs
  flywheel logs [job-name]         # Tail job log
  flywheel attach <job-name>       # Attach to background job

Options:
  --bg      Run in background tmux session
  --resume  Resume interrupted refine from last checkpoint
USAGE
}

doctor() {
  note "Checking dependencies..."
  for cmd in git tmux ntm bd bv apr ubs claude codex gemini; do require_cmd "$cmd"; done
  note "Running: ntm deps -v"
  ntm deps -v
  note "OK: toolchain present."
}

checkout_branch() {
  local branch="${1:-}" base="${2:-}"
  [[ -n "$branch" ]] || die "checkout requires <branch>"
  local root; root="$(git_root)" || die "Not in a git repo."
  cd "$root"; git fetch --all --prune
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    note "Checking out: $branch"; git checkout "$branch"; return 0
  fi
  if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
    note "Tracking origin/$branch"; git checkout -b "$branch" --track "origin/$branch"; return 0
  fi
  [[ -z "$base" ]] && base="$(git rev-parse --abbrev-ref HEAD)"
  note "Creating: $branch (from $base)"
  git checkout "$base"; git pull --ff-only || true; git checkout -b "$branch"
}

init_repo() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"; cd "$root"
  mkdir -p .flywheel planning
  [[ -f .flywheel/config.env ]] || echo "# Repo-local overrides" > .flywheel/config.env
  note "Initializing Beads..."; bd init 2>/dev/null || true
  bd config set sync.branch beads-sync 2>/dev/null || true
  if [[ ! -f AGENTS.md ]]; then
    cat > AGENTS.md <<'EOF'
# AGENTS.md
Multi-agent repo via NTM. Use Agent Mail for coordination. Run UBS before commits.
EOF
    note "Wrote AGENTS.md"
  fi
  note "Repo initialized. Next: flywheel plan"
}

plan_session() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local rounds="${1:-$FW_INTERVIEW_ROUNDS}"
  local session; session="$(basename "$root")"
  cd "$root"
  note "Spawning planning session: $session"
  ntm spawn "$session" --cc=1
  sleep 3
  ntm send "$session" --no-cass-check --all "You are the INTERVIEWER. Run ${rounds} interview rounds, then write planning/INTERVIEW_TRANSCRIPT.md and planning/PLAN_v0.md." || true
  note "Attaching..."
  ntm attach "$session"
}

# Save refine state for resume
save_refine_state() {
  local root="$1" current_iter="$2" total_iters="$3" plan_in="$4"
  mkdir -p "$root/.flywheel"
  cat > "$root/.flywheel/refine-state.json" <<EOF
{
  "current_iter": $current_iter,
  "total_iters": $total_iters,
  "plan_in": "$plan_in",
  "timestamp": "$(date -Iseconds)",
  "status": "in_progress"
}
EOF
}

# Load refine state
load_refine_state() {
  local root="$1"
  local state_file="$root/.flywheel/refine-state.json"
  if [[ -f "$state_file" ]]; then
    cat "$state_file"
  else
    echo "{}"
  fi
}

# Mark refine complete
complete_refine_state() {
  local root="$1"
  local state_file="$root/.flywheel/refine-state.json"
  if [[ -f "$state_file" ]]; then
    local tmp=$(mktemp)
    sed 's/"status": "in_progress"/"status": "complete"/' "$state_file" > "$tmp"
    mv "$tmp" "$state_file"
  fi
}

# Find latest iteration file
find_latest_iter() {
  local root="$1"
  local latest=$(ls -t "$root/planning/PLAN_codex_iter"*.md 2>/dev/null | head -1)
  if [[ -n "$latest" ]]; then
    # Extract iteration number
    echo "$latest" | grep -oE 'iter[0-9]+' | grep -oE '[0-9]+'
  else
    echo "0"
  fi
}

refine_plan() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local iters="$FW_PLAN_ITERS" plan_in="planning/PLAN_v0.md" run_bg=false do_resume=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --iters) iters="$2"; shift 2;;
      --plan) plan_in="$2"; shift 2;;
      --bg|--background) run_bg=true; shift;;
      --resume) do_resume=true; shift;;
      *) die "Unknown: $1";;
    esac
  done
  cd "$root"

  # Handle resume
  local start_iter=1
  if [[ "$do_resume" == true ]]; then
    local state=$(load_refine_state "$root")
    local saved_status=$(echo "$state" | grep -oP '(?<="status": ")[^"]*' 2>/dev/null || echo "")
    
    if [[ "$saved_status" == "in_progress" ]]; then
      local saved_iter=$(echo "$state" | grep -oP '(?<="current_iter": )[0-9]+' 2>/dev/null || echo "0")
      local saved_total=$(echo "$state" | grep -oP '(?<="total_iters": )[0-9]+' 2>/dev/null || echo "$iters")
      local saved_plan=$(echo "$state" | grep -oP '(?<="plan_in": ")[^"]*' 2>/dev/null || echo "")
      
      note "Found interrupted refine at iteration $saved_iter/$saved_total"
      start_iter=$((saved_iter))
      iters=$saved_total
      
      # Find the latest completed iteration file
      local latest_iter=$(find_latest_iter "$root")
      if [[ "$latest_iter" -gt 0 ]]; then
        plan_in="planning/PLAN_codex_iter${latest_iter}.md"
        start_iter=$((latest_iter + 1))
        note "Resuming from iteration $start_iter (found iter${latest_iter})"
      fi
    else
      note "No interrupted refine found. Starting fresh."
    fi
  else
    # Check if there is an incomplete refine
    local state=$(load_refine_state "$root")
    local saved_status=$(echo "$state" | grep -oP '(?<="status": ")[^"]*' 2>/dev/null || echo "")
    if [[ "$saved_status" == "in_progress" ]]; then
      local latest_iter=$(find_latest_iter "$root")
      note "WARNING: Found interrupted refine at iter${latest_iter}"
      note "Use --resume to continue, or proceed to start fresh"
      read -p "Start fresh? [y/N] " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        note "Aborting. Use: flywheel refine --resume"
        return 1
      fi
    fi
  fi

  [[ -f "$plan_in" ]] || die "Missing: $plan_in"

  if [[ "$run_bg" == true ]]; then
    local job_name="refine-$(basename "$root")-$(date +%H%M%S)"
    local log_file="$root/planning/.refine-${job_name}.log"
    note "Starting background job: $job_name"
    note "Log: $log_file"
    local resume_flag=""
    [[ "$do_resume" == true ]] && resume_flag="--resume"
    tmux new-session -d -s "$job_name" "cd '$root' && flywheel refine --iters $iters --plan '$plan_in' $resume_flag 2>&1 | tee '$log_file'; echo '=== DONE ===' >> '$log_file'; sleep 10"
    note "Commands: flywheel jobs | flywheel logs $job_name | flywheel attach $job_name"
    return 0
  fi

  mkdir -p planning
  note "Codex refinement: model=$FW_GPT_PLAN_MODEL iters=$iters (starting at $start_iter)"
  
  local prev="$plan_in"
  for i in $(seq "$start_iter" "$iters"); do
    local next="planning/PLAN_codex_iter${i}.md"
    
    # Save state before each iteration
    save_refine_state "$root" "$i" "$iters" "$prev"
    
    note "Iteration $i/$iters: $prev -> $next"
    
    if ! codex exec --model "$FW_GPT_PLAN_MODEL" \
      --config "model_reasoning_effort=\"${FW_CODEX_REASONING}\"" \
      --output-last-message "$next" \
      "Read ${prev}. Rewrite into a better engineering plan with specificity, testability, parallelizability. Markdown only."; then
      note "ERROR: Iteration $i failed. State saved. Resume with: flywheel refine --resume"
      return 1
    fi
    
    prev="$next"
    note "Checkpoint saved: $next"
  done
  
  cp "$prev" planning/PLAN.md
  complete_refine_state "$root"
  note "Done: planning/PLAN.md (from $iters iterations)"
}

make_beads() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local plan="planning/PLAN.md" min_beads="50" run_bg=false
  while [[ $# -gt 0 ]]; do
    case "$1" in 
      --plan) plan="$2"; shift 2;; 
      --min-beads) min_beads="$2"; shift 2;; 
      --bg|--background) run_bg=true; shift;;
      *) die "Unknown: $1";; 
    esac
  done
  cd "$root"
  [[ -f "$plan" ]] || die "Missing: $plan"
  bd init 2>/dev/null || true

  local session; session="beads-$(basename "$root")"
  local prompt="You are a task decomposition expert. Read ${plan} and create Beads tasks.

RULES:
1. Create an EPIC first for the main feature
2. Create ${min_beads}+ sub-tasks with clear acceptance criteria
3. Use priorities: P1 (critical path), P2 (important), P3 (polish)
4. Set dependencies between tasks using --parent

COMMANDS:
- br add -t epic -p P1 'Epic Title' 'Epic description'
- br add -t task -p P1 'Task Title' 'Detailed acceptance criteria'
- br update <id> --parent <epic-id>

After creating all tasks, run: bv --robot-triage
Then say BEADS_COMPLETE when done."

  if [[ "$run_bg" == true ]]; then
    local log_file="$root/planning/.beads-${session}.log"
    note "Starting background beads job: $session"
    note "Log: $log_file"
    tmux new-session -d -s "$session" "cd '$root' && claude --dangerously-skip-permissions --print '$prompt' 2>&1 | tee '$log_file'; echo '=== DONE ===' >> '$log_file'; sleep 10"
    note "Commands: flywheel jobs | flywheel logs $session | flywheel attach $session"
    return 0
  fi

  note "Spawning beads creation session: $session"
  
  if tmux has-session -t "$session" 2>/dev/null; then
    note "Session $session already exists. Attaching..."
    tmux attach -t "$session"
    return 0
  fi

  tmux new-session -d -s "$session" "cd '$root' && claude --dangerously-skip-permissions"
  sleep 3
  tmux send-keys -t "$session" "$prompt" Enter
  
  note "Beads creation started in session: $session"
  read -p "Attach now? [Y/n] " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Nn]$ ]]; then
    tmux attach -t "$session"
  fi
}

startwork() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local session; session="$(basename "$root")"
  local cc_n="$FW_CC" cod_n="$FW_COD" gmi_n="$FW_GMI"
  while [[ $# -gt 0 ]]; do
    case "$1" in --cc) cc_n="$2"; shift 2;; --cod) cod_n="$2"; shift 2;; --gmi) gmi_n="$2"; shift 2;; *) die "Unknown: $1";; esac
  done
  cd "$root"
  local args=()
  [[ "$cc_n" -gt 0 ]] && args+=(--cc="$cc_n")
  [[ "$cod_n" -gt 0 ]] && args+=(--cod="$cod_n")
  [[ "$gmi_n" -gt 0 ]] && args+=(--gmi="$gmi_n")
  note "Spawning: $session cc=$cc_n cod=$cod_n gmi=$gmi_n"
  ntm spawn "$session" "${args[@]}"
  sleep 3
  ntm send "$session" --no-cass-check --all "Swarm SOP: bv --robot-triage, claim bead, reserve files, implement, close bead, notify." || true
  note "Attach: ntm attach $session"
}

show_status() {
  local root; root="$(git_root)" || die "Not in a git repo."
  cd "$root"
  
  echo "╔════════════════════════════════════════════════════════════════╗"
  echo "║              FLYWHEEL STATUS: $(basename "$root")"
  echo "╚════════════════════════════════════════════════════════════════╝"
  echo ""
  
  # Refine status
  echo "=== REFINE STATUS ==="
  local state_file="$root/.flywheel/refine-state.json"
  if [[ -f "$state_file" ]]; then
    local status=$(grep -oP '(?<="status": ")[^"]*' "$state_file" 2>/dev/null || echo "unknown")
    local current=$(grep -oP '(?<="current_iter": )[0-9]+' "$state_file" 2>/dev/null || echo "?")
    local total=$(grep -oP '(?<="total_iters": )[0-9]+' "$state_file" 2>/dev/null || echo "?")
    local ts=$(grep -oP '(?<="timestamp": ")[^"]*' "$state_file" 2>/dev/null || echo "?")
    echo "  Status: $status"
    echo "  Progress: iteration $current / $total"
    echo "  Last update: $ts"
  else
    echo "  No refine state found"
  fi
  
  # List iterations
  echo ""
  echo "=== PLAN ITERATIONS ==="
  ls -la planning/PLAN*.md 2>/dev/null | awk '{print "  " $NF " (" $5 " bytes, " $6 " " $7 " " $8 ")"}' || echo "  None"
  
  # Latest iteration
  local latest=$(find_latest_iter "$root")
  if [[ "$latest" -gt 0 ]]; then
    echo ""
    echo "  Latest: iter$latest"
    echo "  Resume: flywheel refine --resume"
  fi
  
  # Beads status
  echo ""
  echo "=== BEADS STATUS ==="
  if [[ -d .beads ]]; then
    local total=$(bv 2>/dev/null | grep -c "^" || echo "0")
    local open=$(br list --status=open 2>/dev/null | grep -c "^" || echo "0")
    echo "  Total tasks: $total"
    echo "  Open tasks: $open"
  else
    echo "  Beads not initialized"
  fi
  
  # Active sessions
  echo ""
  echo "=== ACTIVE SESSIONS ==="
  tmux ls 2>/dev/null | grep -E "$(basename "$root")" || echo "  None"
}

list_jobs() {
  note "Background jobs:"
  tmux list-sessions 2>/dev/null | grep -E "^(refine-|beads-)" || echo "  None"
  echo ""
  note "All sessions:"
  tmux list-sessions 2>/dev/null || echo "  None"
}

view_logs() {
  local job="${1:-}"
  local root; root="$(git_root 2>/dev/null || echo .)"
  if [[ -z "$job" ]]; then
    local f; f=$(find "$root" -name ".refine-*.log" -o -name ".beads-*.log" 2>/dev/null | sort -t- -k3 -r | head -1)
    [[ -n "$f" ]] && { note "Tailing: $f"; tail -f "$f"; } || die "No logs found"
  else
    local f; f=$(find "$root" -name "*${job}*.log" 2>/dev/null | head -1)
    [[ -n "$f" ]] && { note "Tailing: $f"; tail -f "$f"; } || die "No log for: $job"
  fi
}

attach_job() {
  local job="${1:-}"
  [[ -n "$job" ]] || die "Specify job. Use 'flywheel jobs'"
  tmux has-session -t "$job" 2>/dev/null && tmux attach -t "$job" || die "No session: $job"
}

main() {
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    doctor) doctor;;
    checkout) checkout_branch "$@";;
    init) init_repo;;
    plan) local r=""; while [[ $# -gt 0 ]]; do case "$1" in --rounds) r="$2"; shift 2;; *) die "Unknown: $1";; esac; done; plan_session "${r:-}";;
    refine) refine_plan "$@";;
    beads) make_beads "$@";;
    startwork) startwork "$@";;
    status) show_status;;
    jobs) list_jobs;;
    logs) view_logs "${1:-}";;
    attach) attach_job "${1:-}";;
    ""|-h|--help|help) usage;;
    *) usage; die "Unknown: $cmd";;
  esac
}

main "$@"
