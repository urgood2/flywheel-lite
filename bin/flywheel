#!/usr/bin/env bash
set -euo pipefail

# Flywheel-Lite with persistent tmux sessions + approval mode

die() { echo "ERROR: $*" >&2; exit 1; }
note() { echo "==> $*" >&2; }

# Smart attach: use switch-client if already in tmux, else attach
smart_attach() {
  local target="$1"
  if [[ -n "${TMUX:-}" ]]; then
    tmux switch-client -t "$target"
  else
    tmux attach -t "$target"
  fi
}

# Load prompt from external file
load_prompt() {
  local name="$1"
  local prompt_file="$HOME/.config/flywheel/prompts/${name}.md"
  if [[ -f "$prompt_file" ]]; then
    cat "$prompt_file"
  else
    echo ""
  fi
}

# Get system prompt (base rules for all agents)
get_system_prompt() {
  load_prompt "SYSTEM_PROMPT"
}

# Build agent prompt with system rules prepended
build_agent_prompt() {
  local agent_type="$1"
  local base_prompt="$2"
  local system_prompt worker_prompt full_prompt=""
  
  system_prompt=$(get_system_prompt)
  worker_prompt=$(load_prompt "AGENT_WORKER")
  
  [[ -n "$system_prompt" ]] && full_prompt="$system_prompt

---

"
  [[ -n "$worker_prompt" ]] && full_prompt="${full_prompt}${worker_prompt}

---

"
  full_prompt="${full_prompt}${base_prompt}"
  echo "$full_prompt"
}


load_config() {
  local repo_root="${1:-}"
  [[ -f "$HOME/.config/flywheel/config.env" ]] && source "$HOME/.config/flywheel/config.env"
  [[ -n "$repo_root" && -f "$repo_root/.flywheel/config.env" ]] && source "$repo_root/.flywheel/config.env"
  : "${FW_INTERVIEW_ROUNDS:=2}" "${FW_PLAN_ITERS:=3}" "${FW_CC:=3}" "${FW_COD:=2}" "${FW_GMI:=1}"
  : "${FW_CLAUDE_MODEL:=opus}" "${FW_CODEX_IMPL_MODEL:=gpt-5.3-codex}" "${FW_CODEX_COMMIT_MODEL:=gpt-5.2-codex}" "${FW_GPT_PLAN_MODEL:=gpt-5.3}"
  : "${FW_CODEX_REASONING:=high}" "${FW_GEMINI_MODEL:=gemini-2.5-pro}" "${FW_SAFE:=0}"
  : "${FW_COMMIT:=true}" "${FW_WATCHDOG:=true}" "${FW_WATCHDOG_INTERVAL:=120}" "${FW_REVIEW_NUDGE_INTERVAL:=900}"
}

git_root() { git rev-parse --show-toplevel 2>/dev/null || return 1; }
# Sanitize session name for tmux (only allow a-z, A-Z, 0-9, _, -)

# Check if in a git worktree (not main repo)
is_worktree() {
  local git_dir
  git_dir=$(git rev-parse --git-dir 2>/dev/null)
  [[ "$git_dir" == *".git/worktrees/"* ]] || [[ -f ".git" ]]
}

# Clean planning files for fresh start
clean_planning() {
  local root; root="$(git_root)" || die "Not in a git repo."
  cd "$root"
  local removed=0
  shopt -s nullglob
  for f in planning/PLAN_v*.md planning/PLAN.md planning/PLAN_synthesized.md planning/PLAN_pre_compete.md planning/INTERVIEW_TRANSCRIPT.md; do
    [[ -f "$f" ]] && rm -f "$f" && ((removed++)) || true
  done
  for f in planning/PLAN_codex_iter*.md planning/PLAN_opus_*.md planning/gpt_round*.md planning/integration_round*.log; do
    [[ -f "$f" ]] && rm -f "$f" && ((removed++)) || true
  done
  shopt -u nullglob
  [[ -d "planning/competing" ]] && rm -rf "planning/competing" && ((removed++)) || true
  [[ $removed -gt 0 ]] && note "Cleaned $removed stale planning file(s)" || note "No stale planning files found"
}

sanitize_session_name() {
  echo "$1" | tr "@.:" "---" | sed "s/[^a-zA-Z0-9_-]/-/g"
}

require_cmd() { command -v "$1" >/dev/null 2>&1 || die "Missing: $1"; }

ensure_brownfield_preflight() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  if command -v flywheel-brownfield-preflight >/dev/null 2>&1; then
    (cd "$root" && flywheel-brownfield-preflight --quiet "$@") || note "Warning: brownfield preflight failed"
  else
    note "Warning: flywheel-brownfield-preflight not found (skipping brownfield preflight)"
  fi
}

usage() {
  cat >&2 <<'USAGE'
flywheel â€” oh-my-opencode style workflow on Agent Flywheel

Usage:
  flywheel doctor
  flywheel checkout <branch> [base]
  flywheel init
  flywheel preflight [--refresh]                # Generate/refresh brownfield preflight context
  flywheel plan [--rounds N]
  flywheel refine [--max N] [--plan FILE]     # Approval mode (default), tmux session
  flywheel refine --iters N                  # Fixed iterations mode (legacy)
  flywheel beads [--plan FILE] [--min-beads N]
  flywheel compete                              # Generate 4 competing plans + synthesize
  flywheel startwork [--cc N] [--cod N] [--gmi N] [--commit|--no-commit] [--watchdog|--no-watchdog]
  flywheel add-commit                          # Add commit agent to running session
  flywheel add-watchdog [interval]             # Add watchdog to running session
  flywheel status                              # Show refine/beads progress
  flywheel attach [session]                    # Attach to refine/beads session
  flywheel plan-pro [--rounds N] [--plan FILE]        # GPT Pro guided planning (manual steps)
  flywheel polish [--max N]              # Iterative bead refinement (6-9x)
  flywheel finalize [--push]            # Commit beads, optionally push
  flywheel sync                         # Full finalize + push
  flywheel qa                           # Spawn QA agent to verify codebase
  flywheel jobs                                # List all sessions

Refine runs in a persistent tmux session. Detach with Ctrl+B D, reattach with:
  flywheel attach
USAGE
}

doctor() {
  note "Checking dependencies..."
  for cmd in git tmux ntm bd bv apr ubs claude codex gemini; do require_cmd "$cmd"; done
  note "Running: ntm deps -v"
  ntm deps -v
  note "Checking Agent Mail MCP server..."
  if curl -sf http://127.0.0.1:8765/mcp/ -X POST -H "Content-Type: application/json" \
    -d '{"jsonrpc":"2.0","method":"ping","id":1}' >/dev/null 2>&1; then
    note "OK: Agent Mail MCP server reachable"
    am list-projects 2>/dev/null | head -5
  else
    note "WARNING: Agent Mail MCP server not reachable at http://127.0.0.1:8765/mcp/"
    note "  Agents will not be able to use file reservations or messaging"
  fi
  note "OK: toolchain present."
}

checkout_branch() {
  local branch="${1:-}" base="${2:-}"
  [[ -n "$branch" ]] || die "checkout requires <branch>"
  local root; root="$(git_root)" || die "Not in a git repo."
  cd "$root"; git fetch --all --prune
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    note "Checking out: $branch"; git checkout "$branch"; return 0
  fi
  if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
    note "Tracking origin/$branch"; git checkout -b "$branch" --track "origin/$branch"; return 0
  fi
  [[ -z "$base" ]] && base="$(git rev-parse --abbrev-ref HEAD)"
  note "Creating: $branch (from $base)"
  git checkout "$base"; git pull --ff-only || true; git checkout -b "$branch"
}

init_repo() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"; cd "$root"
  mkdir -p .flywheel planning
  [[ -f .flywheel/config.env ]] || echo "# Repo-local overrides" > .flywheel/config.env
  note "Initializing Beads..."; bd init 2>/dev/null || true
  bd config set sync.branch beads-sync 2>/dev/null || true
  # Install Agent Mail git pre-commit guard (prevents commits on reserved files)
  note "Installing Agent Mail guard..."
  am guard install "$root" 2>/dev/null && note "Agent Mail guard installed" || note "Warning: Agent Mail guard not installed (am not available or server down)"
  # Ensure .beads/ is NOT gitignored (required for sync)
  if grep -q "^\.beads/$" .gitignore 2>/dev/null; then
    sed -i "/^\.beads\/$/d" .gitignore
    note "Removed .beads/ from .gitignore (required for beads sync)"
  fi
  if [[ ! -f AGENTS.md ]]; then
    cat > AGENTS.md <<'EOF'
# AGENTS.md
Multi-agent repo via NTM. Use Agent Mail for coordination. Run UBS before commits.
EOF
    note "Wrote AGENTS.md"
  fi
  if is_worktree; then note "Detected worktree - cleaning stale planning files..."; clean_planning; fi
  note "Repo initialized. Next: flywheel plan"
}

plan_session() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local rounds="${1:-$FW_INTERVIEW_ROUNDS}"
  local session; session="$(sanitize_session_name "$(basename "$root")")"
  cd "$root"
  ensure_brownfield_preflight
  local preflight_file="${FW_BROWNFIELD_PREFLIGHT_FILE:-planning/BROWNFIELD_PREFLIGHT.md}"
  note "Spawning planning session: $session"
  
  # Always create session detached first, then add agents
  # This avoids "no space for new pane" errors when running from small terminals
  if tmux has-session -t "$session" 2>/dev/null; then
    note "Session already exists"
  else
    tmux new-session -d -s "$session" -c "$root" -x 200 -y 50
  fi
  sleep 1
  ntm add "$session" --cc=1 || note "Warning: could not add Claude agent"
  
  sleep 3
  ntm send "$session" --no-cass-check --all "You are the INTERVIEWER. First read ${preflight_file} (brownfield baseline). Use it to ground decisions in existing architecture and constraints. Then run ${rounds} interview rounds, and write planning/INTERVIEW_TRANSCRIPT.md and planning/PLAN_v0.md." || true
  note "Attaching..."
  smart_attach "$session"
}

find_latest_iter() {
  local root="$1"
  local latest=$(ls -t "$root/planning/PLAN_codex_iter"*.md 2>/dev/null | head -1)
  if [[ -n "$latest" ]]; then
    echo "$latest" | grep -oE 'iter[0-9]+' | grep -oE '[0-9]+'
  else
    echo "0"
  fi
}

# The actual refine loop (runs inside tmux)
_refine_loop() {
  local root="$1" max_iters="$2" plan_in="$3" start_iter="$4" until_approved="$5"
  
  cd "$root"
  source "$HOME/.config/flywheel/config.env" 2>/dev/null || true
  : "${FW_GPT_PLAN_MODEL:=gpt-5.3}" "${FW_CODEX_REASONING:=high}"
  
  mkdir -p planning .flywheel
  local preflight_file="${FW_BROWNFIELD_PREFLIGHT_FILE:-planning/BROWNFIELD_PREFLIGHT.md}"
  
  local prev="$plan_in"
  local i="$start_iter"
  local approved=false

  if [[ "$until_approved" == "true" ]]; then
    echo ""
    echo "Mode: APPROVAL (iterate until plan is approved, max=$max_iters)"
  else
    echo ""
    echo "Mode: FIXED ($max_iters iterations)"
  fi
  echo ""

  while [[ $i -le $max_iters ]]; do
    local next="planning/PLAN_codex_iter${i}.md"
    local verdict_file="/tmp/codex-verdict-$$.txt"
    
    cat > "$root/.flywheel/refine-state.json" <<EOF
{"current_iter": $i, "total_iters": $max_iters, "plan_in": "$prev", "until_approved": $until_approved, "timestamp": "$(date -Iseconds)", "status": "in_progress"}
EOF
    
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  ITERATION $i / $max_iters"
    echo "  Input: $prev"
    if [[ "$until_approved" == "true" ]]; then
      echo "  Mode: Approval (stop early if APPROVED)"
    fi
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    if [[ "$until_approved" == "true" ]]; then
      if ! codex exec --model "$FW_GPT_PLAN_MODEL" \
        --config "model_reasoning_effort=\"${FW_CODEX_REASONING}\"" \
        --output-last-message "$verdict_file" \
        "Review this engineering plan file: ${prev}

Also read ${preflight_file} if it exists and ensure the plan integrates with current brownfield architecture (avoid greenfield rewrites unless explicitly justified).

Your task:
1. Check for: specificity, testability, parallelizability, completeness, clarity
2. If the plan is EXCELLENT and ready for implementation, output ONLY: APPROVED
3. If the plan needs improvement, output an IMPROVED version of the COMPLETE plan. CRITICAL: Preserve ALL sections, tasks, and details - do not omit or summarize anything. Only add clarity, fix issues, or expand where needed. (markdown only, no commentary)

Be strict. Only approve if the plan is truly implementation-ready."; then
        echo ""
        echo "ERROR: Iteration $i failed!"
        echo "State saved. Restart with: flywheel refine"
        read -p "Press Enter to exit..."
        return 1
      fi
      
      if grep -q "^APPROVED$" "$verdict_file" 2>/dev/null; then
        echo ""
        echo "âœ… Plan APPROVED at iteration $i"
        approved=true
        rm -f "$verdict_file"
        break
      else
        mv "$verdict_file" "$next"
        echo "  â†’ Refined: $next ($(wc -c < "$next") bytes)"
        prev="$next"
      fi
    else
      if ! codex exec --model "$FW_GPT_PLAN_MODEL" \
        --config "model_reasoning_effort=\"${FW_CODEX_REASONING}\"" \
        --output-last-message "$next" \
        "Read ${prev}. Also read ${preflight_file} if it exists and keep compatibility with existing code architecture. Rewrite into an improved engineering plan with better specificity, testability, and parallelizability. CRITICAL: Preserve ALL sections, tasks, and details from the original - do not omit or summarize anything. Only add clarity, fix issues, or expand where needed. Markdown only."; then
        echo ""
        echo "ERROR: Iteration $i failed!"
        echo "State saved. Restart with: flywheel refine"
        read -p "Press Enter to exit..."
        return 1
      fi
      
      prev="$next"
      echo "âœ“ Iteration $i complete: $next ($(wc -c < "$next") bytes)"
    fi
    
    i=$((i + 1))
  done
  
  cp "$prev" planning/PLAN.md
  
  cat > "$root/.flywheel/refine-state.json" <<EOF
{"current_iter": $((i > max_iters ? max_iters : i)), "total_iters": $max_iters, "plan_in": "$prev", "until_approved": $until_approved, "approved": $approved, "timestamp": "$(date -Iseconds)", "status": "complete"}
EOF
  
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  if [[ "$approved" == "true" ]]; then
    echo "  âœ… REFINEMENT COMPLETE (APPROVED)"
  elif [[ "$until_approved" == "true" ]]; then
    echo "  âš ï¸  REFINEMENT COMPLETE (max iterations reached, NOT approved)"
    echo "  Review planning/PLAN.md manually or run again with higher --max"
  else
    echo "  REFINEMENT COMPLETE"
  fi
  echo "  Final plan: planning/PLAN.md ($(wc -c < planning/PLAN.md) bytes)"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "Next: flywheel beads"
  echo ""
  read -p "Press Enter to close this session..."
}

refine_plan() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local max_iters="${FW_PLAN_ITERS:-10}" plan_in="planning/PLAN_v0.md" until_approved=true
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --iters) max_iters="$2"; until_approved=false; shift 2;;
      --max) max_iters="$2"; shift 2;;
      --plan) plan_in="$2"; shift 2;;
      --no-approve) until_approved=false; shift;;
      --_loop) shift; _refine_loop "$@"; return;;
      *) die "Unknown: $1";;
    esac
  done
  cd "$root"
  ensure_brownfield_preflight
  
  local session="refine-$(sanitize_session_name "$(basename "$root")")"
  local start_iter=1
  
  if tmux has-session -t "$session" 2>/dev/null; then
    note "Refine session already running: $session"
    note "Attaching... (Ctrl+B D to detach)"
    sleep 1
    smart_attach "$session"
    return 0
  fi
  
  local state_file="$root/.flywheel/refine-state.json"
  if [[ -f "$state_file" ]]; then
    local status=$(grep -oP '"status":\s*"\K[^"]*' "$state_file" 2>/dev/null || echo "")
    if [[ "$status" == "in_progress" ]]; then
      local latest_iter=$(find_latest_iter "$root")
      if [[ "$latest_iter" -gt 0 ]]; then
        note "Found interrupted refine at iteration $latest_iter"
        plan_in="planning/PLAN_codex_iter${latest_iter}.md"
        start_iter=$((latest_iter + 1))
        local saved_total=$(grep -oP '"total_iters":\s*\K[0-9]+' "$state_file" 2>/dev/null || echo "$max_iters")
        [[ "$saved_total" -gt "$max_iters" ]] && max_iters="$saved_total"
        local saved_approve=$(grep -oP '"until_approved":\s*\K[a-z]+' "$state_file" 2>/dev/null || echo "true")
        until_approved="$saved_approve"
        note "Resuming from iteration $start_iter (max: $max_iters, approval: $until_approved)"
      fi
    elif [[ "$status" == "complete" ]]; then
      note "Previous refine completed. Starting fresh."
    fi
  fi
  
  [[ -f "$plan_in" ]] || die "Missing: $plan_in"
  
  note "Starting refine session: $session"
  if [[ "$until_approved" == "true" ]]; then
    note "Mode: APPROVAL (until approved, max $max_iters)"
  else
    note "Mode: FIXED ($max_iters iterations)"
  fi
  note "Input: $plan_in"
  echo ""
  note "Detach: Ctrl+B D | Reattach: flywheel attach"
  echo ""
  sleep 2
  
  tmux new-session -d -s "$session" \
    "cd '$root' && flywheel refine --_loop '$root' $max_iters '$plan_in' $start_iter $until_approved"
  
  smart_attach "$session"
}

make_beads() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local plan="planning/PLAN.md" min_beads="50"
  while [[ $# -gt 0 ]]; do
    case "$1" in 
      --plan) plan="$2"; shift 2;; 
      --min-beads) min_beads="$2"; shift 2;; 
      *) die "Unknown: $1";; 
    esac
  done
  cd "$root"
  ensure_brownfield_preflight
  local preflight_file="${FW_BROWNFIELD_PREFLIGHT_FILE:-planning/BROWNFIELD_PREFLIGHT.md}"
  [[ -f "$plan" ]] || die "Missing: $plan"
  bd init 2>/dev/null || true

  local session="beads-$(sanitize_session_name "$(basename "$root")")"
  
  # Check for existing session
  if tmux has-session -t "$session" 2>/dev/null; then
    note "Beads session already running: $session"
    note "Attaching... (Ctrl+B D to detach)"
    sleep 1
    smart_attach "$session"
    return 0
  fi

  local prompt="OK so now read ALL of ${plan} and ${preflight_file} (if present); please take ALL of that and elaborate on it and use it to create a comprehensive and granular set of beads for all this with tasks, subtasks, and dependency structure overlaid, with detailed comments so the whole thing is totally self-contained and self-documenting (including relevant background, reasoning/justification, considerations, etc.-- anything we would want our future self to know about the goals and intentions and thought process and how it serves the over-arching goals of the project.).

The beads should be so detailed that we never need to consult back to the original markdown plan document.

Remember to ONLY use the bd/br tool to create and modify the beads and add the dependencies.

Use these commands:
- br add -t epic -p P1 'Epic Title' 'Epic description with full context'
- br add -t task -p P1 'Task Title' 'Detailed acceptance criteria and context'
- br update <id> --parent <epic-id>
- br dep add <id> --blocked-by <other-id>

Create at least ${min_beads} beads. When done, run: bv --robot-triage
Then say BEADS_COMPLETE."

  note "Starting beads session: $session"
  note "Detach anytime with: Ctrl+B D"
  note "Reattach with: flywheel attach"
  sleep 2

  tmux new-session -d -s "$session" "cd '$root' && claude --dangerously-skip-permissions"
  sleep 3
  tmux send-keys -t "$session" "$prompt" Enter
  smart_attach "$session"
}

# Spawn terminal-based commit loop (non-interactive Codex one-shot every 15 minutes).
spawn_commit_loop_pane() {
  local session="$1" root="$2"
  local prompt_file="$HOME/.config/flywheel/prompts/COMMIT_AGENT_ONESHOT.md"
  [[ -f "$prompt_file" ]] || prompt_file="$HOME/.config/flywheel/prompts/COMMIT_AGENT.md"
  [[ -f "$prompt_file" ]] || die "Commit prompt not found at ~/.config/flywheel/prompts/COMMIT_AGENT_ONESHOT.md or COMMIT_AGENT.md"

  if tmux list-panes -t "$session" -F '#{pane_title}' 2>/dev/null | grep -qi "commit"; then
    note "Commit loop pane already exists in session: $session"
    return 0
  fi

  local loop_script="/tmp/flywheel-commit-loop-${session}.sh"
  cat > "$loop_script" <<EOF
#!/usr/bin/env bash
set -euo pipefail
cd "$root"
PROMPT_FILE="$prompt_file"
MODEL="${FW_CODEX_COMMIT_MODEL}"
while true; do
  echo "=== COMMIT CYCLE \$(date) ==="
  if [[ ! -f "\$PROMPT_FILE" ]]; then
    echo "ERROR: prompt file missing: \$PROMPT_FILE"
  else
    if ! codex exec --dangerously-bypass-approvals-and-sandbox --model "\$MODEL" --config model_reasoning_effort="high" - < "\$PROMPT_FILE"; then
      echo "Commit cycle failed (non-zero exit); continuing."
    fi
  fi
  echo "=== DONE. Sleeping 15m ==="
  sleep 900
done
EOF
  chmod +x "$loop_script"

  local new_pane
  new_pane=$(tmux split-window -t "${session}:1" -c "$root" -d -P -F "#{pane_index}" "$loop_script")
  tmux select-pane -t "${session}:1.${new_pane}" -T "commit-loop" 2>/dev/null || true
  note "Commit loop started in pane ${new_pane} (Codex: ${FW_CODEX_COMMIT_MODEL})"
}

# New startwork function with commit agent support
startwork() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local session; session="$(sanitize_session_name "$(basename "$root")")"
  local cc_n="$FW_CC" cod_n="$FW_COD" gmi_n="$FW_GMI"
  local commit_agent="$FW_COMMIT"
  local watchdog="$FW_WATCHDOG"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --cc) cc_n="$2"; shift 2;;
      --cod) cod_n="$2"; shift 2;;
      --gmi) gmi_n="$2"; shift 2;;
      --commit) commit_agent=true; shift;;
      --no-commit) commit_agent=false; shift;;
      --watchdog) watchdog=true; shift;;
      --no-watchdog) watchdog=false; shift;;
      *) die "Unknown: $1";;
    esac
  done
  cd "$root"

  # Safety: prevent shared-state runs from git worktrees unless explicitly allowed.
  if is_worktree && [[ "${FW_ALLOW_WORKTREE:-0}" != "1" ]]; then
    die "Refusing to run in git worktree: $root. Use an independent clone to avoid shared Beads DB state. Override only if intentional: FW_ALLOW_WORKTREE=1"
  fi

  # Safety: require Beads DB to live inside this repo.
  local fw_db_path
  fw_db_path=$(bd info 2>/dev/null | sed -n "s/^Database: //p" | head -n1)
  [[ -n "$fw_db_path" ]] || die "Could not determine Beads DB path. Run: bd init --force --from-jsonl"
  [[ "$fw_db_path" == "$root/.beads/"* || "$fw_db_path" == "$root/.beads/beads.db" ]] || die "Unsafe Beads DB path: $fw_db_path (outside repo). Re-initialize local DB: bd init --force --from-jsonl"

  # Verify Agent Mail MCP server is healthy before spawning agents
  if curl -sf http://127.0.0.1:8765/mcp/ -X POST -H "Content-Type: application/json" \
    -d '{"jsonrpc":"2.0","method":"ping","id":1}' >/dev/null 2>&1; then
    note "Agent Mail MCP server: OK"
  else
    note "WARNING: Agent Mail MCP not reachable - agents cannot coordinate file reservations"
    note "  Start with: cd ~/mcp_agent_mail && uv run python -m mcp_agent_mail.cli serve-http &"
  fi

  # Calculate totals. Commit agent now runs on Codex (not Claude).
  local total_cc="$cc_n"
  
  local args=()
  [[ "$total_cc" -gt 0 ]] && args+=(--cc="$total_cc")
  [[ "$cod_n" -gt 0 ]] && args+=(--cod="$cod_n")
  [[ "$gmi_n" -gt 0 ]] && args+=(--gmi="$gmi_n")
  
  note "Spawning: $session cc=$cc_n cod=$cod_n gmi=$gmi_n commit=$commit_agent"
  # Create session detached first to avoid "no space for new pane" errors
  if tmux has-session -t "$session" 2>/dev/null; then
    note "Session already exists, adding agents..."
  else
    tmux new-session -d -s "$session" -c "$root" -x 200 -y 50
    sleep 1
  fi
  
  # Add agents using ntm add (works with existing session)
  [[ "$total_cc" -gt 0 ]] && ntm add "$session" --cc="$total_cc"
  [[ "$cod_n" -gt 0 ]] && ntm add "$session" --cod="${cod_n}:${FW_CODEX_IMPL_MODEL}"
  [[ "$gmi_n" -gt 0 ]] && ntm add "$session" --gmi="$gmi_n"
  sleep 3
  
  # Pane layout: 1=shell, then agent panes in order: Claude, Codex, Gemini.
  # Commit loop is spawned as a separate terminal process after agents.
  local pane=2
  
  # Send prompts to Claude worker agents (panes 2 to cc_n+1)
  if [[ "$cc_n" -gt 0 ]]; then
    local cc_prompt
    cc_prompt=$(build_agent_prompt "claude" "AGENT ROLE: Architect/Implementer. START: Task selection order: (1) bd list --status in_progress --type task --limit 10 and continue one; (2) if none, run bd ready --type task --limit 10 and claim one with bd update <ID> --status in_progress; (3) if none, run bd ready --type bug --limit 10 and claim one with bd update <ID> --status in_progress; (4) if no ready task/bug exists, do NOT claim epics via bv --robot-next; document blockers and stop.")
    for i in $(seq 1 "$cc_n"); do
      note "Sending prompt to Claude Worker pane $pane"
      tmux send-keys -t "${session}:1.${pane}" "$cc_prompt" Enter
      sleep 0.5
      pane=$((pane + 1))
    done
  fi
  
  # Send prompts to Codex agents (needs delay between text and Enter)
  if [[ "$cod_n" -gt 0 ]]; then
    local cod_prompt
    cod_prompt=$(build_agent_prompt "codex" "AGENT ROLE: Implementer. START: Task selection order: (1) bd list --status in_progress --type task --limit 10 and continue one; (2) if none, run bd ready --type task --limit 10 and claim one with bd update <ID> --status in_progress; (3) if none, run bd ready --type bug --limit 10 and claim one with bd update <ID> --status in_progress; (4) if no ready task/bug exists, do NOT claim epics via bv --robot-next; document blockers and stop.")
    for i in $(seq 1 "$cod_n"); do
      note "Sending prompt to Codex pane $pane"
      tmux send-keys -t "${session}:1.${pane}" "$cod_prompt"
      sleep 0.3
      tmux send-keys -t "${session}:1.${pane}" Enter
      sleep 0.5
      pane=$((pane + 1))
    done
  fi
  
  # Send prompts to Gemini agents (needs delay between text and Enter)
  if [[ "$gmi_n" -gt 0 ]]; then
    local gmi_prompt
    gmi_prompt=$(build_agent_prompt "gemini" "AGENT ROLE: Reviewer. START: Pick review target via fallback chain: (1) bd list --ready --limit 5; (2) if none, bv --robot-next; review claimed/closed work appropriately.")
    for i in $(seq 1 "$gmi_n"); do
      note "Sending prompt to Gemini pane $pane"
      tmux send-keys -t "${session}:1.${pane}" "$gmi_prompt"
      sleep 0.3
      tmux send-keys -t "${session}:1.${pane}" Enter
      sleep 0.5
      pane=$((pane + 1))
    done
  fi
  
  if [[ "$commit_agent" == true ]]; then
    spawn_commit_loop_pane "$session" "$root"
    note "Commit loop running in dedicated pane (15-min cycles)"
  fi

  # Start watchdog in pane 1 (shell pane) to auto-nudge idle agents
  if [[ "$watchdog" == "true" ]]; then
    note "Starting watchdog (nudge every ${FW_WATCHDOG_INTERVAL}s)"
    local watchdog_cmd="flywheel-watchdog '$session' '$FW_WATCHDOG_INTERVAL'"
    [[ "${FW_COMPLETE_ALL_STATUSES:-0}" == "1" ]] && watchdog_cmd="FW_COMPLETE_ALL_STATUSES=1 ${watchdog_cmd}"
    tmux send-keys -t "${session}:1.1" "$watchdog_cmd" Enter
  fi

  note "Attach: ntm attach $session"
}

# Add commit agent to an already running session
add_commit_agent() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local session; session="$(sanitize_session_name "$(basename "$root")")"

  if ! tmux has-session -t "$session" 2>/dev/null; then
    die "No session '$session' running. Use 'flywheel startwork' first."
  fi

  note "Adding commit loop to session: $session"
  spawn_commit_loop_pane "$session" "$root"
}

# Add watchdog to an already running session
add_watchdog() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local session; session="$(sanitize_session_name "$(basename "$root")")"
  local interval="${1:-$FW_WATCHDOG_INTERVAL}"

  if ! tmux has-session -t "$session" 2>/dev/null; then
    die "No session '$session' running. Use 'flywheel startwork' first."
  fi

  # Check if watchdog already running in pane 1
  if tmux capture-pane -t "${session}:1.1" -p 2>/dev/null | tail -5 | grep -q "watchdog"; then
    note "Watchdog appears to already be running in pane 1"
    return 0
  fi

  note "Starting watchdog in session: $session (interval: ${interval}s)"
  local watchdog_cmd="flywheel-watchdog '$session' '$interval'"
  [[ "${FW_COMPLETE_ALL_STATUSES:-0}" == "1" ]] && watchdog_cmd="FW_COMPLETE_ALL_STATUSES=1 ${watchdog_cmd}"
  tmux send-keys -t "${session}:1.1" "$watchdog_cmd" Enter
  note "Watchdog started"
}

show_status() {
  local root; root="$(git_root)" || die "Not in a git repo."
  local name=$(basename "$root")
  cd "$root"
  
  echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  echo "â•‘  FLYWHEEL STATUS: $name"
  echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  
  # Check for running refine session
  if tmux has-session -t "refine-$name" 2>/dev/null; then
    echo "ğŸ”„ REFINE SESSION RUNNING: refine-$name"
    echo "   Attach: flywheel attach"
    echo ""
  fi
  
  # Refine state
  echo "=== REFINE STATUS ==="
  local state_file="$root/.flywheel/refine-state.json"
  if [[ -f "$state_file" ]]; then
    local status=$(grep -oP '(?<="status": ")[^"]*' "$state_file" 2>/dev/null || echo "unknown")
    local current=$(grep -oP '(?<="current_iter": )[0-9]+' "$state_file" 2>/dev/null || echo "?")
    local total=$(grep -oP '(?<="total_iters": )[0-9]+' "$state_file" 2>/dev/null || echo "?")
    echo "  Status: $status"
    echo "  Progress: $current / $total iterations"
  else
    echo "  No refine started"
  fi
  
  # Iterations
  echo ""
  echo "=== PLAN FILES ==="
  local iter_count=$(ls planning/PLAN_codex_iter*.md 2>/dev/null | wc -l)
  echo "  Iterations: $iter_count"
  local latest=$(find_latest_iter "$root")
  [[ "$latest" -gt 0 ]] && echo "  Latest: iter$latest ($(wc -c < "planning/PLAN_codex_iter${latest}.md") bytes)"
  [[ -f planning/PLAN.md ]] && echo "  PLAN.md: $(wc -c < planning/PLAN.md) bytes"
  
  # Sessions
  echo ""
  echo "=== SESSIONS ==="
  tmux ls 2>/dev/null | grep -E "(refine-|beads-)?$name" | sed 's/^/  /' || echo "  None"
}

attach_session() {
  local root; root="$(git_root 2>/dev/null)" || root="."
  local name=$(basename "$root")
  local target="${1:-}"
  
  # If no target, try to find a relevant session
  if [[ -z "$target" ]]; then
    # Priority: refine > beads > project
    if tmux has-session -t "refine-$name" 2>/dev/null; then
      target="refine-$name"
    elif tmux has-session -t "beads-$name" 2>/dev/null; then
      target="beads-$name"
    elif tmux has-session -t "$name" 2>/dev/null; then
      target="$name"
    else
  flywheel compete                              # Generate 4 competing plans + synthesize
      die "No active session found. Run flywheel refine or flywheel startwork first."
    fi
  fi
  
  note "Attaching to: $target (Ctrl+B D to detach)"
  tmux attach -t "$target"
}

list_jobs() {
  echo "=== FLYWHEEL SESSIONS ==="
  tmux list-sessions 2>/dev/null | grep -E "^(refine-|beads-)" | sed 's/^/  /' || echo "  None"
  echo ""
  echo "=== ALL SESSIONS ==="
  tmux list-sessions 2>/dev/null | sed 's/^/  /' || echo "  None"
  echo ""
  echo "Attach: flywheel attach <session-name>"
}

is_pane_idle() {
  local session="$1" pane="$2"
  local output
  output=$(tmux capture-pane -t "${session}:1.${pane}" -p -S -15 2>/dev/null) || return 1

  # Check recent pane output for active work indicators.
  local recent
  recent=$(echo "$output" | sed '/^[[:space:]]*$/d' | tail -12)
  if echo "$recent" | grep -qiE "(Running PreToolUse hooks|Running\\.\\.\\.|Runningâ€¦|Waiting\\.\\.\\.|Waitingâ€¦|Contemplating|Perambulating|Thinking|Analyzing|Processing|Searching|Reading|Writing|Executing|esc to interrupt)" 2>/dev/null; then
    return 1  # Working
  fi

  # Claude idle patterns - conversational.
  if echo "$output" | grep -qiE "(next steps|what.*should|shall i|want me to|waiting for|please confirm|let me know|ready to|can i help)" 2>/dev/null; then
    return 0  # Idle
  fi

  # Claude Code idle - at the input prompt.
  local last_cc_line
  last_cc_line=$(echo "$output" | sed '/^[[:space:]]*$/d' | tail -1)
  if echo "$last_cc_line" | grep -qE "bypass permissions|shift.tab to cycle" 2>/dev/null; then
    return 0  # Idle - Claude Code at input prompt
  fi

  # Codex idle detection:
  # idle only when we see a prompt line paired with the shortcuts status line.
  local codex_last_two codex_prompt_line codex_status_line
  codex_last_two=$(echo "$output" | sed '/^[[:space:]]*$/d' | tail -2)
  codex_prompt_line=$(echo "$codex_last_two" | head -1)
  codex_status_line=$(echo "$codex_last_two" | tail -1)
  if echo "$codex_prompt_line" | grep -qE "^[[:space:]]*â€º " 2>/dev/null && echo "$codex_status_line" | grep -qE "\? for shortcuts" 2>/dev/null; then
    return 0  # Idle - Codex at input prompt
  fi

  # Gemini idle patterns.
  if echo "$output" | grep -qiE "(i can help|would you like|let me know|ready for)" 2>/dev/null; then
    return 0  # Idle
  fi

  return 1  # Assume working by default
}

nudge_agents() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  local session; session="$(sanitize_session_name "$(basename "$root")")"
  local force=false
  local now_ts
  now_ts=$(date +%s)
  local review_nudge_dir="$HOME/.cache/flywheel/review-nudges"
  mkdir -p "$review_nudge_dir"
  [[ "${1:-}" == "--force" ]] && force=true
  
  note "Checking agents in session: $session"
  local nudged=0 skipped=0
  set +e
  
  for pane in $(tmux list-panes -t "$session" -F '#{pane_index}' 2>/dev/null | tail -n +2); do
    local pane_title
    pane_title=$(tmux display-message -t "${session}:1.${pane}" -p '#{pane_title}' 2>/dev/null) || continue

    # Skip commit agent - it runs on its own cycle
    if [[ "$pane_title" == *"commit"* ]]; then
      note "  Skipping pane $pane - commit agent (autonomous)"
      skipped=$((skipped + 1))
      continue
    fi

    # Detect review agent by title or output content
    local is_review=false
    if [[ "${pane_title,,}" == *"review"* ]]; then
      is_review=true
    fi
    if [[ "$is_review" == false ]]; then
      local pane_output
      pane_output=$(tmux capture-pane -t "${session}:1.${pane}" -p -S -50 2>/dev/null) || pane_output=""
      if [[ "$pane_output" == *"REVIEW_AGENT"* ]] || [[ "$pane_output" == *"review closed beads"* ]] || [[ "$pane_output" == *"Read-Only Code Reviewer"* ]]; then
        is_review=true
      fi
    fi

    if [[ "$force" == true ]] || is_pane_idle "$session" "$pane"; then
      # Throttle reviewer nudges so review prompts are not spammed every watchdog cycle.
      if [[ "$is_review" == true ]] && [[ "$force" != true ]]; then
        local review_stamp_file="${review_nudge_dir}/${session}-pane${pane}.ts"
        local last_review_nudge=0
        if [[ -f "$review_stamp_file" ]]; then
          last_review_nudge=$(cat "$review_stamp_file" 2>/dev/null || echo 0)
        fi
        if [[ "$last_review_nudge" =~ ^[0-9]+$ ]]; then
          local review_elapsed=$((now_ts - last_review_nudge))
          if (( review_elapsed < FW_REVIEW_NUDGE_INTERVAL )); then
            local review_wait=$((FW_REVIEW_NUDGE_INTERVAL - review_elapsed))
            note "  Skipping pane $pane - review cooldown (${review_wait}s left)"
            skipped=$((skipped + 1))
            continue
          fi
        fi
      fi

      note "  Nudging pane $pane ($pane_title)"
      # Different nudge messages based on agent type
      local nudge_msg="CONTINUE. Task selection order: run bd list --status in_progress --type task --limit 10 and continue one; if none run bd ready --type task --limit 10 and claim one; if still none run bd ready --type bug --limit 10 and claim one. Do NOT claim epics via bv --robot-next."
      if [[ "$is_review" == true ]]; then
        nudge_msg="CONTINUE reviewing. Run: br list --status=closed | head -10 to find recently closed beads, then review them. Create beads for any issues found. Do NOT edit files."
      elif [[ "$pane_title" == *"cod"* ]]; then
        nudge_msg="You are an autonomous coding agent. Run bd list --status in_progress --type task --limit 10 and continue one task. If none, run bd ready --type task --limit 10 and claim one with bd update <ID> --status in_progress. If still none, run bd ready --type bug --limit 10 and claim one with bd update <ID> --status in_progress. Do NOT claim epics via bv --robot-next. Do NOT wait for confirmation - just code."
      fi
      tmux send-keys -t "${session}:1.${pane}" "$nudge_msg"
      sleep 0.3
      tmux send-keys -t "${session}:1.${pane}" Enter
      if [[ "$is_review" == true ]]; then
        echo "$now_ts" > "${review_nudge_dir}/${session}-pane${pane}.ts"
      fi
      sleep 0.2
      nudged=$((nudged + 1))
    else
      note "  Skipping pane $pane - working"
      skipped=$((skipped + 1))
    fi
  done
  
  set -e
  note "Nudged: $nudged | Skipped: $skipped"
}


main() {
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    doctor) doctor;;
    checkout) checkout_branch "$@";;
    init) init_repo;;
    clean) clean_planning;;
    preflight) if command -v flywheel-brownfield-preflight >/dev/null 2>&1; then flywheel-brownfield-preflight "$@"; else die "Missing: flywheel-brownfield-preflight"; fi;;
    plan) local r=""; while [[ $# -gt 0 ]]; do case "$1" in --rounds) r="$2"; shift 2;; *) die "Unknown: $1";; esac; done; plan_session "${r:-}";;
    refine) refine_plan "$@";;
    beads) make_beads "$@";;
    compete) compete_plans;;
    plan-pro) ensure_brownfield_preflight; local r="" p=""; while [[ $# -gt 0 ]]; do case "$1" in --rounds) r="$2"; shift 2;; --plan) p="$2"; shift 2;; *) die "Unknown: $1";; esac; done; flywheel-plan-pro "${r:-3}" ${p:+--plan "$p"};;
    polish) ensure_brownfield_preflight; local m=""; local p=""; while [[ $# -gt 0 ]]; do case "$1" in --max) m="$2"; shift 2;; --plan) p="$2"; shift 2;; *) die "Unknown: $1";; esac; done; flywheel-polish "${m:-9}" "${p:-planning/PLAN.md}";;
    startwork) startwork "$@";;
    add-commit) add_commit_agent;;
    add-watchdog) add_watchdog "$@";;
    status) show_status;;
    jobs) list_jobs;;
    attach) attach_session "${1:-}";;
    finalize) finalize_work "$@";;
    sync) sync_to_remote;;
    qa) run_qa;;
    nudge) nudge_agents "$@";;
    ""|-h|--help|help) usage;;
    *) usage; die "Unknown: $cmd";;
  esac
}


compete_plans() {
  local root; root="$(git_root)" || die "Not in a git repo."
  load_config "$root"
  cd "$root"
  ensure_brownfield_preflight
  mkdir -p planning/competing
  
  local context_file="planning/PLAN_v0.md"
  [[ -f "$context_file" ]] || context_file="planning/INTERVIEW_TRANSCRIPT.md"
  [[ -f "$context_file" ]] || die "No context file. Run flywheel plan first or create planning/PLAN_v0.md"
  
  local branch; branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
  local session="compete-$(sanitize_session_name "$(basename "$root")-$branch")"
  
  if tmux has-session -t "$session" 2>/dev/null; then
    note "Compete session running. Attaching... (Ctrl+B D to detach)"
    sleep 1
    smart_attach "$session"
    return 0
  fi
  
  note "Starting competitive planning: $session"
  note "Context: $context_file ($(wc -c < "$context_file") bytes)"
  note ""
  note "Generates 5 competing plans (2x Opus, 1x Codex xhigh, 1x GPT-5.2 xhigh, 1x Gemini Pro)"
  note "then synthesizes with GPT-5.2 Pro (xhigh reasoning)."
  note ""
  note "Detach: Ctrl+B D | Reattach: flywheel attach"
  sleep 2
  
  tmux new-session -d -s "$session" "cd '"$root"' && flywheel-compete '"$context_file"'"
  smart_attach "$session"
}




# ============================================================================
# FINALIZATION & QA
# ============================================================================

finalize_work() {
  local root; root="$(git_root)" || die "Not in a git repo."
  local do_push=false
  while [[ $# -gt 0 ]]; do
    case "$1" in --push) do_push=true; shift;; *) die "Unknown: $1";; esac
  done
  cd "$root"

  note "=== Finalization Checklist ==="

  # 1. Show work status
  note "1. Checking open beads..."
  local in_progress
  in_progress=$(br list --status=in_progress 2>/dev/null | grep -c "id" 2>/dev/null) || in_progress=0
  [[ "$in_progress" -gt 0 ]] && note "   âš ï¸  $in_progress beads still in_progress" || note "   âœ… No beads in_progress"

  # 2. Run UBS if available
  if command -v ubs >/dev/null 2>&1; then
    note "2. Running UBS scan..."
    ubs . 2>/dev/null || note "   âš ï¸  UBS found issues (review output)"
  else
    note "2. Skipping UBS (not installed)"
  fi

  # 3. Sync beads
  note "3. Syncing beads..."
  br sync --flush-only 2>/dev/null || true
  git add .beads/ 2>/dev/null || true

  # 4. Stage and commit
  note "4. Staging changes..."
  git add -A
  if ! git diff --cached --quiet; then
    note "   Committing..."
    git commit -m "Flywheel checkpoint: $(date +%Y-%m-%d\ %H:%M)" || true
  else
    note "   Nothing to commit"
  fi

  # 5. Push if requested
  if [[ "$do_push" == true ]]; then
    note "5. Pushing to remote..."
    git pull --rebase || die "Pull failed - resolve conflicts first"
    git push || die "Push failed"
    note "   âœ… Pushed successfully"
  else
    note "5. Skipping push (use --push or 'flywheel sync')"
  fi

  # 6. Final status
  note "6. Final status:"
  git status --short
}

sync_to_remote() {
  local root; root="$(git_root)" || die "Not in a git repo."
  cd "$root"
  note "=== Full Sync ==="
  finalize_work --push
}

run_qa() {
  local root; root="$(git_root)" || die "Not in a git repo."
  local project; project="$(basename "$root")"
  local session="${project}-qa"
  cd "$root"

  note "Spawning QA agent (Opus) via ntm in session: $session"

  # Kill existing sessions
  tmux kill-session -t "$session" 2>/dev/null || true
  tmux kill-session -t "$project" 2>/dev/null || true

  # Load QA prompt
  local prompt_file="$HOME/.config/flywheel/prompts/QA_AGENT.md"
  [[ -f "$prompt_file" ]] || prompt_file="/data/projects/flywheel-lite/prompts/QA_AGENT.md"
  
  local qa_prompt
  if [[ -f "$prompt_file" ]]; then
    qa_prompt="$(cat "$prompt_file")"
  else
    qa_prompt="You are a QA AGENT. Verify this codebase is ready for sync. START NOW."
  fi

  # Spawn with ntm (uses project directory name), then rename to -qa
  ntm spawn "$project" --cc=1:opus --no-user --prompt="$qa_prompt" --no-cass-context 2>/dev/null
  sleep 2
  tmux rename-session -t "$project" "$session" 2>/dev/null || true

  note "QA session started: $session"
  note "Attach with: ntm attach $session"
  sleep 1
  smart_attach "$session"
}

main "$@"
